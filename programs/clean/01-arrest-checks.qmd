---
author: Sarah Cohen
date: last-modified
title: Arrest table cleanup
subtitle: ""
format:
  scdefault-html:
    code-fold: show
    toc: false
execute:
  echo: fenced
  warning: true
  message: true
  error: true
  cache: false
  eval: true

engine: knitr
---



The arrests table cleanup is done in this document. See the documentation for details on why and how it ends up.

```{r}
#| label: setup
#| message: false
#| echo: fenced
#| error: true
#| code-fold: true

# assumes pacman has been installed already


# typical packages
pacman::p_load("tidyverse", "glue", "lubridate", "janitor", "readxl", "here", "googlesheets4")
here::i_am("programs/clean/01-arrest-checks.qmd")


#additional packages here
library(GGally)
library(skimr)
library(forcats)


orig_xl_date <- mdy("10/14/2025")

```

::: confidential
Not for publication
:::

Data Last Updated: `{r} format(orig_xl_date, "%B %e, %Y")`

## Read original Excel file from Deportation Data Project

The original Excel file has 19 columns that have to be imported with variable types to take care of Zip codes, dates and missing values. Reading everything as text has two problems: Lack of precision in numbers, and dates converted to serial numbers. The data header is at row 7 and the data starts row 8.

Two collumns are dropped because they add no information: `final_program_group` is always "ICE", `apprehension_county` is always missing. This could change in the future.

I renamed the columns to a) lowercase everything; b) replace spaces and special characters with underscores.  (It uses the `janitor::clean_names()` function, so it's always done the same way.


```{r}
#| label: get-arrest-rawdata
#| message: true
#| warning: true

var_types <- c ("guess", rep("text",9 ), "guess", "text", "text", "guess", "skip", "guess", rep("text", 3),
              rep("skip", 3), "text")

orig_xls <- read_excel(here(
                      "data/raw/ddp/2025-ICLI-00019_2024-ICFO-39357_ERO_AdminArrests_07312025.xlsx"
                      ),
                      skip=6,
                      col_types = var_types
                      )  |>
            clean_names() |>
            rowid_to_column(var="orig_row_id") |>
            # county is always empty
            select ( - c(apprehension_county, final_program_group))



```


## Basic cleanup

At the end of this, I'll change the order of the columns so they make a little more sense.

#### 1. Remove true dupes

```{r}
#| label: remove-dupes

deduped_xl <- orig_xls |>
  distinct ( pick (apprehension_date:unique_identifier))


```

#### 2. Date columns

Convert date-only to date; create new column with date only from those with time.

```{r}

deduped_date_fix <-
  deduped_xl |>
  mutate  ( apprehension_date_part = as_date( apprehension_date) ,
            across ( c(final_order_date, departed_date), as_date)
  )



```


## Create convenience columns

I've created a spreadsheet of lookup values that is easier to use than copying and pasting. It also ensures that I use the same lookups for different tables with the same column definitions.

Read the data lookup sheet (easier than copying and pasting into the code):

```{r}
#| label: get-lookups

lookup_tables <- read_excel (here("documentation/background/master_data_dictionary_lookups.xlsx"),
                            sheet="lookups",
                            na= c("", "N/A") )


```

### Lookup table applications

In practice, I worked on the lookup tables one at a time. The decisions were made based on the combinations I saw and other peoples' coding. See the documentation for more detail on individual column definitions.

(This actually works one at a time, not as one big process, so it could be slow on bigger tables. It happens that the arrest table isn't that big and isn't updated very often.)


```{r}

# function to create lookups
# df:       the data frame to work on as data frame
# apply_to: name of column that should be looked up as character value
# new_name: name of the column I want created as character value
# Requires: lookup_table read in previous step

lkp_table_values <- function ( df,
                              apply_to,
                              new_name)  {

  # lookup_tables exists, and has columns `initial value`, `recode` and `varname`
  # df is a data frame with a column that matches the apply_to argument
  lkp_filtered = lookup_tables |>
    filter ( varname == apply_to)

  lkp_selected = lkp_filtered |>
    select ( lkp_val = `initial value`,
            # this is how to apply a char value as a column name.
            !!new_name := recode)

  return_df = df |>
    left_join ( lkp_selected,
                join_by (!!sym(apply_to)  == lkp_val ) )

  return (return_df)

  }

```

Apply the lookup table to the original:

```{r}
#| label: collapse-final-program

list_of_vars <- c("final_program" = "final_program_type",
                    "apprehension_method" = "apprehension_method_type")

working_table <- deduped_date_fix

for ( n in names(list_of_vars) ) {
  working_table = lkp_table_values ( working_table, n , list_of_vars[n])
}

#working_table <- lkp_table_values( deduped_date_fix, "final_program", "final_program_type")
#working_table <- working_table (arrest_prog_types , "apprehension_method", "apprehension_method_type")
#working_table <- working_table ()



# skim(working_table)

```


#### Case category and case status

These seem to have something to do with one another, since they have the same number of missing values. Try visualizing it to see what is happening

```{r}


```
